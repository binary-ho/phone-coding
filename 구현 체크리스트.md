
## Phase 1: 프로젝트 기반 설정 및 초기화

이 단계에서는 TypeScript 기반의 GitHub Action을 개발하기 위한 기본 프로젝트 구조와 환경을 설정합니다.

### **1.1. TypeScript GitHub Action 프로젝트 구조 설정**
- [ ] `npm init -y` 명령어로 `package.json` 파일을 생성한다.
- [ ] 프로젝트 루트에 `src` 디렉토리를 생성하고, 그 안에 `main.ts` 파일을 생성한다.
- [ ] `tsconfig.json` 파일을 생성하고, TypeScript 컴파일 옵션을 설정한다. (target: `es2022`, module: `NodeNext`, moduleResolution: `NodeNext`, outDir: `dist` 등)

### **1.2. 의존성 패키지 설치**
- [ ] `npm install typescript @types/node --save-dev` 명령어로 TypeScript 관련 패키지를 설치한다.
- [ ] `npm install @actions/core @actions/github @actions/exec` 명령어로 GitHub Actions 개발에 필수적인 툴킷을 설치한다.
- [ ] `npm install @google/genai` 명령어로 Gemini API와 통신하기 위한 공식 SDK를 설치한다.[1]

### **1.3. `action.yml` 명세 정의**
- [ ] 프로젝트 루트에 `action.yml` 파일을 생성한다.
- [ ] Action의 이름(`name`), 설명(`description`), 실행 환경(`runs`)을 정의한다.
    - `runs.using`: `'node20'`
    - `runs.main`: `'dist/index.js'`
- [ ] Action이 받을 입력값(`inputs`)을 정의한다.
    - `gemini-api-key`: 필수(`required: true`), Gemini API 키.
    - `github-token`: 필수(`required: true`), 기본값 `${{ github.token }}`.
    - `mode`: 필수 아님, 기본값 `review`, (값: `review`, `summarize`).

### **1.4. 빌드 및 패키징 설정**
- [ ] `npm install @vercel/ncc --save-dev` 명령어로 `ncc` 패키지를 설치한다. `ncc`는 모든 의존성을 포함한 단일 JavaScript 파일로 코드를 컴파일하는 데 사용된다.
- [ ] `package.json`의 `scripts` 섹션에 빌드 명령어를 추가한다: `"build": "ncc build src/main.ts --source-map --license licenses.txt"`.

### **1.5. 인증 정보 설정**
- [ ] Google AI Studio에서 Gemini API 키를 발급받는다.[2]
- [ ] Action을 테스트할 GitHub 리포지토리의 `Settings > Secrets and variables > Actions`에서 `GEMINI_API_KEY`라는 이름으로 발급받은 키를 저장한다.[2, 3]

### **1.6. Phase 1 최종 검증**
- [ ] `npm run build` 명령어가 오류 없이 실행되고, `dist/index.js` 파일이 생성되는지 확인한다.
- [ ] `action.yml` 파일이 올바른 형식과 내용을 가지고 있는지 검토한다.
- [ ] GitHub 리포지토리에 `GEMINI_API_KEY` 시크릿이 정상적으로 설정되었는지 확인한다.

---

## **Phase 2: 핵심 모듈 구현**

이 단계에서는 Action의 핵심 로직을 담당하는 각 모듈을 TypeScript로 구현합니다. 각 모듈은 `src` 디렉토리 하위에 별도의 파일로 생성하여 높은 응집도를 유지합니다.

### **2.1. 컨텍스트 제공자 (`src/context.ts`) 구현**
- [ ] `getPrContext` 함수를 구현한다.
    - `@actions/github`의 `context` 객체를 사용하여 PR 번호, 제목, 본문, 베이스 및 헤드 SHA를 추출하여 반환한다.
- [ ] `getPrDiff` 함수를 구현한다.
    - `@actions/exec`를 사용하여 `git diff --no-color ${{ baseSha }}..${{ headSha }}` 명령어를 실행한다.[4]
    - `fetch-depth: 0`이 설정된 환경에서 정확한 diff를 얻을 수 있음을 주석으로 명시한다.[5, 6]
    - 실행 결과를 문자열로 반환한다.

### **2.2. 프롬프트 조립기 (`src/prompt.ts`) 구현**
- [ ] `buildPrompt` 함수를 구현한다.
    - 입력: `prTitle`, `prBody`, `diff`, `mode` (`review` 또는 `summarize`).
    - `mode` 값에 따라 분기하여, 각 페르소나("PR 요약", "코드 리뷰어")에 맞는 프롬프트 템플릿을 동적으로 구성한다.
    - 프롬프트 템플릿에는 PR 제목, 본문, diff 내용을 명확한 구분자(예: `--- DIFF ---`)와 함께 삽입한다.
    - 최종적으로 완성된 프롬프트 문자열을 반환한다.

### **2.3. Gemini API 클라이언트 (`src/gemini.ts`) 구현**
- [ ] `callGeminiApi` 함수를 구현한다.
    - `@google/genai` SDK를 사용하여 Gemini 클라이언트를 초기화한다. API 키는 함수의 인자로 받는다.
    - `generativeModel.generateContent()` 메서드를 호출하여 조립된 프롬프트를 API로 전송한다.
    - API 응답에서 텍스트 결과(`response.text()`)를 추출하여 반환한다.
    - API 호출 실패 시를 대비하여 `try-catch` 블록으로 감싸고, 오류를 로깅한다.

### **2.4. 피드백 통합자 (`src/comment.ts`) 구현**
- [ ] `findPreviousComment` 함수를 구현한다.
    - `@actions/github`의 Octokit 클라이언트를 사용하여 `issues.listComments`를 호출한다.
    - 코멘트 본문에 포함될 고유 식별자(예: ``)를 기준으로 기존 코멘트를 검색하여 ID를 반환한다. `peter-evans/find-comment`의 로직을 참고한다.[7]
- [ ] `postOrUpdateComment` 함수를 구현한다.
    - `findPreviousComment`를 호출하여 기존 코멘트 ID를 확인한다.
    - ID가 있으면 `issues.updateComment`를, 없으면 `issues.createComment`를 호출하여 PR에 리뷰 결과를 게시한다. `peter-evans/create-or-update-comment`의 로직을 참고한다.[7]

### **2.5. Phase 2 최종 검증**
- [ ] 각 모듈의 함수들이 예상된 입력에 대해 올바른 타입의 출력을 반환하는지 확인한다. (단위 테스트 전, 타입 레벨 검증)
- [ ] 각 파일이 단일 책임 원칙을 준수하며, 다른 모듈과의 결합도가 낮은지 코드 구조를 검토한다.
- [ ] 모든 외부 API 호출(Git, GitHub API, Gemini API)이 적절한 오류 처리 로직으로 감싸져 있는지 확인한다.

---

## **Phase 3: 오케스트레이션 및 워크플로우 구현**

이 단계에서는 구현된 모듈들을 통합하여 전체 Action의 실행 흐름을 제어하고, 실제 PR에서 Action을 테스트하기 위한 워크플로우를 작성합니다.

### **3.1. 메인 오케스트레이터 (`src/main.ts`) 구현**
- [ ] `run` 비동기 함수를 정의하고 실행한다.
- [ ] `@actions/core`를 사용하여 `gemini-api-key`, `github-token`, `mode` 입력값을 가져온다.
- [ ] **실행 흐름 제어:**
    1. `context.ts`의 함수를 호출하여 PR 컨텍스트와 diff를 가져온다.
    2. `prompt.ts`의 함수를 호출하여 컨텍스트와 `mode`에 맞는 프롬프트를 생성한다.
    3. `gemini.ts`의 함수를 호출하여 생성된 프롬프트로 Gemini API를 실행하고 결과를 받는다.
    4. `comment.ts`의 함수를 호출하여 Gemini의 응답을 PR에 코멘트로 게시하거나 업데이트한다.
- [ ] `core.setFailed()`를 사용하여 전체 프로세스 중 발생하는 모든 오류를 처리한다.

### **3.2. 테스트용 워크플로우 (`.github/workflows/review-bot-test.yml`) 작성**
- [ ] 워크플로우 파일을 생성한다.
- [ ] `on: pull_request` 이벤트에 의해 트리거되도록 설정한다.
- [ ] `permissions` 블록에 `pull-requests: write`와 `contents: read`를 명시한다.[8, 9]
- [ ] **작업(Job) 정의:**
    1. `actions/checkout@v4`을 사용하여 코드를 체크아웃한다. `fetch-depth: 0` 옵션을 반드시 포함한다.[5, 6]
    2. `uses:./` 구문을 사용하여 로컬에 개발 중인 Action을 호출한다.
    3. `with` 블록을 사용하여 `gemini-api-key`와 `github-token`을 Action에 전달한다.
        - `gemini-api-key: ${{ secrets.GEMINI_API_KEY }}`
        - `github-token: ${{ secrets.GITHUB_TOKEN }}`

### **3.3. Phase 3 최종 검증**
- [ ] `main.ts`의 `run` 함수가 각 모듈의 함수를 올바른 순서로, 정확한 인자와 함께 호출하는지 코드 리뷰를 수행한다.
- [ ] 테스트용 워크플로우 파일의 YAML 구문이 유효한지 확인한다.
- [ ] 워크플로우가 PR 생성 및 업데이트 시 정상적으로 트리거될 준비가 되었는지 확인한다.

---

## **Phase 4: 테스트 및 개선**

이 단계에서는 Action의 안정성과 품질을 보장하기 위해 단위 테스트와 통합 테스트를 수행하고, AI의 응답 품질을 개선합니다.

### **4.1. 단위 테스트 작성**
- [ ] `npm install jest @types/jest ts-jest --save-dev` 명령어로 Jest 테스트 프레임워크를 설치한다.
- [ ] `jest.config.js` 파일을 설정한다.
- [ ] `prompt.ts`의 `buildPrompt` 함수에 대한 단위 테스트를 작성한다. (다양한 입력에 대해 예상된 프롬프트가 생성되는지 검증)
- [ ] 다른 모듈의 순수 함수들에 대해서도 단위 테스트를 추가한다.

### **4.2. 통합 테스트 수행**
- [ ] 테스트용 브랜치를 생성하고, 간단한 코드 변경 사항을 커밋한다.
- [ ] 해당 브랜치로 Pull Request를 생성하여 `review-bot-test.yml` 워크플로우를 트리거한다.
- [ ] Action이 성공적으로 실행되고, PR에 예상된 형식의 코멘트를 남기는지 확인한다.
- [ ] 기존 코멘트가 있는 상태에서 PR에 새 커밋을 푸시했을 때, Action이 새 코멘트를 다는 대신 기존 코멘트를 업데이트하는지 확인한다.

### **4.3. 프롬프트 엔지니어링 반복**
- [ ] 통합 테스트 결과로 생성된 AI의 응답 품질을 평가한다.
- [ ] 응답이 만족스럽지 않을 경우, `src/prompt.ts`의 프롬프트 템플릿을 수정한다. (더 명확한 지시, 예시 제공, 출력 형식 지정 등)
- [ ] 프롬프트를 수정한 후, 다시 통합 테스트를 수행하여 개선 여부를 확인하는 과정을 반복한다.

### **4.4. Phase 4 최종 검증**
- [ ] 단위 테스트 커버리지가 핵심 로직을 충분히 포함하는지 확인한다.
- [ ] 통합 테스트 시나리오(최초 생성, 업데이트, 대용량 diff 등)가 의도한 대로 모두 통과했는지 확인한다.
- [ ] 최종 프롬프트가 일관되게 만족스러운 품질의 결과를 생성하는지 최종 평가한다.

---

## **Phase 5: 문서화 및 배포**

이 단계에서는 다른 사용자들이 Action을 쉽게 이해하고 사용할 수 있도록 문서를 작성하고, 공식적으로 버전을 관리하여 배포합니다.

### **5.1. `README.md` 문서 작성**
- [ ] Action의 기능과 목적을 명확하게 설명한다.
- [ ] **Usage** 섹션에 사용자가 복사하여 붙여넣을 수 있는 완전한 워크플로우 예제를 제공한다.
- [ ] **Inputs** 섹션에 `action.yml`에 정의된 모든 입력값에 대한 설명, 필수 여부, 기본값을 표 형식으로 정리한다.
- [ ] **Permissions** 섹션에 워크플로우가 필요로 하는 권한(`pull-requests: write` 등)을 명시한다.

### **5.2. 버전 관리 및 릴리즈**
- [ ] `main` 브랜치에 모든 변경 사항을 병합한다.
- [ ] `git tag -a v1.0.0 -m "Initial release"`와 같이 Git 태그를 생성하여 첫 번째 버전을 표시한다.
- [ ] `git push --follow-tags` 명령어로 태그를 원격 저장소에 푸시한다.
- [ ] 사용자는 이제 워크플로우에서 `@v1`과 같이 안정적인 버전을 참조하여 Action을 사용할 수 있다.

### **5.3. Phase 5 최종 검증**
- [ ] `README.md`의 예제 워크플로우가 실제로 동작하는지 최종 확인한다.
- [ ] 생성된 Git 태그가 올바른 커밋을 가리키고 있는지 확인한다.
- [ ] 다른 리포지토리에서 `@v1` 태그를 사용하여 Action을 호출했을 때 정상적으로 동작하는지 최종 검증한다.

