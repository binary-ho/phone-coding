
# Gemini AI 기반 GitHub 워크플로우 자동화를 위한 구체 구현 계획서
본 문서는 GitHub Actions와 Google Gemini AI를 활용하여 Pull Request(PR) 프로세스를 자동화하는 시스템의 구체적인 구현 계획을 기술한다. 시스템은 모듈식 패키지 구조를 채택하여 낮은 결합도와 높은 응집도를 지향하며, 각 컴포넌트는 명확한 단일 책임을 갖도록 설계한다.
I. 기반 설정 및 구성
시스템의 모든 AI 페르소나가 공유하는 리포지토리 수준의 기본 환경을 설정한다. 이 단계는 시스템의 보안, 안정성 및 컨텍스트 인식 능력의 기반이 되므로 정확한 구성이 필수적이다.
1.1. 인증 및 보안 관리
GitHub Actions 워크플로우와 Google Gemini API 간의 안전한 통신 채널을 구축한다.
 * 1단계: Gemini API 키 발급
   * Google AI Studio에 접속하여 신규 API 키를 생성한다. 개인 개발자 및 소규모 팀이 초기 개발 및 테스트를 시작하기에 가장 간단한 방법이다.
   * 이 키는 상당한 수준의 무료 사용량(예: 분당 60회, 일일 1,000회 요청)을 제공하므로 초기 구현 단계에 적합하다.
 * 2단계: API 키를 GitHub Secret으로 저장
   * 대상 GitHub 리포지토리의 Settings > Secrets and variables > Actions 메뉴로 이동한다.
   * GEMINI_API_KEY라는 이름의 신규 리포지토리 시크릿을 생성하고 발급받은 키 값을 붙여넣는다. 이를 통해 API 키가 워크플로우 로그에 노출되지 않고 암호화된 상태로 안전하게 관리된다.
 * 3단계: .gitignore 파일 업데이트
   * 로컬 Gemini CLI 설정 파일이나 다운로드된 인증 정보가 실수로 Git 리포지토리에 커밋되는 것을 방지하기 위해, 리포지토리 루트의 .gitignore 파일에 다음 내용을 추가한다. 이는 공식 run-gemini-cli 문서에서 권장하는 중요한 보안 및 코드 위생 절차이다.
     # gemini-cli settings

   .gemini/
   # GitHub App credentials
   gha-creds-*.json
   ```
단순 API 키 방식은 초기 설정에 용이하지만, 프로덕션 수준의 보안과 확장성을 요구하는 엔터프라이즈 환경에서는 다른 접근 방식이 요구된다. 장기 수명 인증키는 잠재적인 보안 위협이 될 수 있다. 따라서 이러한 환경에서는 Google Cloud의 Workload Identity Federation (WIF) 사용을 강력히 권장한다. WIF는 GitHub Actions 워크플로우가 OIDC 토큰을 사용하여 단기 수명 Google Cloud 서비스 계정 권한을 획득하도록 허용하는 'credential-less' 방식이다. 이는 장기 키 관리의 필요성을 제거하여 보안 태세를 크게 향상시킨다. 따라서 본 계획서는 초기 구현에는 API 키를 사용하되, 프로덕션 배포 시점에는 WIF로의 전환을 목표로 한다.
1.2. 프로젝트 특화 AI 컨텍스트 (GEMINI.md)
AI 모델에 리포지토리에 대한 지속적이고 고수준의 컨텍스트를 제공하여, 생성되는 응답이 프로젝트 표준에 부합하고 관련성을 갖도록 보장한다.
 * 구현:
   * 리포지토리의 루트 디렉토리에 GEMINI.md 파일을 생성한다.
   * 이 파일은 비용이 많이 드는 모델 파인튜닝 없이 AI의 행동을 유도하는 핵심 메커니즘이다.
   * 파일에는 다음과 같은 핵심 프로젝트 정보를 명확하게 기술한다:
     * 코딩 표준: "모든 TypeScript 코드는 Google TypeScript 스타일 가이드를 준수해야 한다. 들여쓰기는 공백 2칸을 사용한다. default export 사용을 지양한다."
     * 아키텍처 원칙: "본 프로젝트는 마이크로서비스 아키텍처를 기반으로 한다. 불변성(immutability)과 함수형 프로그래밍 패러다임을 우선시한다. 상태 관리는 Redux Toolkit으로 처리한다."
     * 핵심 라이브러리 및 프레임워크: "주요 프론트엔드 프레임워크는 React와 Next.js이다. 테스트에는 Jest와 React Testing Library를 사용한다."
     * 응답 톤앤매너: "피드백을 제공할 때는 건설적이고 교육적인 어조를 유지한다. 제안의 배경이 되는 '이유'를 함께 설명한다."
GEMINI.md 파일은 단순한 설정 파일을 넘어, AI의 "성격"과 도메인 지식을 버전 관리되는 코드의 일부로 취급하는 전략적 결정이다. 모든 워크플로우 프롬프트에 프로젝트 규칙을 하드코딩하는 방식은 유지보수가 어렵고 변경에 취약하다. run-gemini-cli 액션은 GEMINI.md의 내용을 자동으로 모든 프롬프트에 주입하여 이 문제를 해결한다. 결과적으로, 프로젝트의 아키텍처 가이드라인이나 코딩 표준 변경은 GEMINI.md 파일 하나를 수정하는 것으로 충분하며, 모든 변경 사항은 Git 히스토리에 기록된다. 이는 GEMINI.md를 "AI-as-Code" 인프라의 핵심 구성 요소로 격상시키며, 이 시스템의 유지보수성과 확장성을 보장하는 중요한 역할을 수행한다.
II. 패키지: 코어 오케스트레이터 (.github/workflows)
이 패키지는 시스템의 핵심 로직을 정의하는 GitHub Actions 워크플로우 파일들로 구성된다. 중앙 신경 시스템처럼 작동하여 GitHub 이벤트를 감지하고 적절한 AI 페르소나에게 작업을 분배한다.
2.1. 중앙 디스패처 (gemini-dispatch.yml)
PR 코멘트를 통해 요청되는 모든 온디맨드 AI 상호작용을 위한 단일 진입점을 생성한다. 이는 워크플로우 중복을 방지하고 모듈성을 증진시킨다.
 * 구현:
   * .github/workflows/gemini-dispatch.yml 경로에 파일을 생성한다.
   * 이 워크플로우는 issue_comment 이벤트 중 created 타입에 의해서만 트리거된다.
   * 코멘트 내용이 @gemini-cli로 시작하는 경우에만 실행되도록 조건부 로직을 추가한다.
   * 주요 역할은 코멘트 본문에서 /review, /generate-tests와 같은 명령어를 파싱하고, workflow_dispatch 이벤트를 사용하여 해당 명령어를 처리할 전문 워크플로우를 트리거하는 것이다. 이때 명령어와 컨텍스트 정보를 입력값으로 전달한다.
   * 이 디스패처 패턴은 run-gemini-cli 액션의 공식 문서에서 권장하는 모범 사례이다.
이 디스패처 패턴은 시스템의 확장성과 유지보수성을 보장하는 핵심적인 아키텍처 결정이다. 이벤트 소스(사용자 코멘트)와 비즈니스 로직(특정 AI 작업)을 분리(decoupling)하기 때문이다. 만약 모든 로직을 단일 워크플로우 파일에 구현한다면, 새로운 /refactor와 같은 명령어를 추가할 때마다 거대하고 복잡한 파일을 수정해야 하므로 오류 발생 가능성이 커진다. 반면, 디스패처 패턴에서는 refactor.yml이라는 새로운 워크플로우 파일을 추가하고 디스패처에 라우팅 로직 한 줄만 추가하면 되므로, 기존 기능에 미치는 영향을 최소화하면서 시스템을 안전하게 확장할 수 있다. 이는 CI/CD 환경에서 단일 책임 원칙(Single Responsibility Principle)을 구현한 구체적인 사례이다.
2.2. 주 PR 워크플로우 (pull-request.yml)
Pull Request가 생성되거나 업데이트될 때마다 자동으로 실행되는 작업들을 정의한다.
 * 구현:
   * .github/workflows/pull-request.yml 경로에 파일을 생성한다.
   * 트리거: pull_request 이벤트의 types: [opened, synchronize]에 반응하도록 설정한다. opened는 PR 생성 시, synchronize는 새로운 커밋이 푸시될 때마다 워크플로우를 실행하여 리뷰가 항상 최신 상태를 유지하도록 보장한다.
   * 권한: 워크플로우가 PR에 코멘트를 작성하고 리포지토리 코드를 읽을 수 있도록 permissions 블록에 pull-requests: write와 contents: read를 명시한다.
   * 작업 (Jobs):
     * summarize: opened 이벤트에서만 실행되는 작업. "PR 요약" 페르소나를 호출한다.
     * review: opened와 synchronize 이벤트 모두에서 실행되는 작업. "코드 리뷰어" 페르소나를 호출한다.
2.3. 페르소나별 워크플로우 (review.yml, generate-tests.yml)
각 AI 페르소나의 로직을 자체 워크플로우 파일에 캡슐화하여 높은 응집도와 유지보수성을 달성한다.
 * 구현:
   * .github/workflows/review.yml과 같은 페르소나별 파일을 생성한다.
   * 트리거: 이 워크플로우들은 gemini-dispatch.yml로부터 workflow_dispatch 이벤트를 통해 트리거된다.
   * 구조: 각 파일은 단일 작업을 포함하며, 표준적인 단계 순서를 따른다:
     * 코드 체크아웃
     * 컨텍스트 수집 (코드 변경사항, PR 본문 등)
     * 페르소나별 프롬프트 구성
     * google-github-actions/run-gemini-cli 액션 호출
     * 결과를 포맷팅하여 PR에 코멘트로 게시
III. 패키지: 컨텍스트 제공자
이 모듈은 Gemini 모델에 전달할 고품질의 컨텍스트 정보를 수집, 처리, 조합하는 책임을 진다. AI 출력의 품질은 이 컨텍스트의 품질에 정비례한다.
3.1. 코드 변경사항 (Diff) 추출
Pull Request에 의해 도입된 코드 수정 사항을 정확하게 포착한다.
 * 1단계: 전체 히스토리 체크아웃
   * actions/checkout@v4 액션은 반드시 fetch-depth: 0 옵션과 함께 사용되어야 한다. 기본값인 fetch-depth: 1은 얕은 클론(shallow clone)을 수행하여 베이스 브랜치와의 정확한 diff를 계산하는 데 필요한 Git 히스토리를 포함하지 않기 때문에, 이 설정은 필수적이다.
 * 2단계: Diff 액션 실행
   * GrantBirki/git-diff-action@vX.X.X 액션을 활용한다. 이 액션은 json_diff_file_output 파라미터를 통해 diff 결과를 구조화된 JSON 형식으로 출력하는 기능 때문에 선택되었다.
   * 구성:
     * base_branch: ${{ github.event.pull_request.base.sha }}: diff의 기준점을 명시적으로 설정하여 정확성을 보장한다.
     * json_diff_file_output: diff.json: 결과를 파일로 저장하여 다음 단계에서 읽어오도록 한다. 이는 diff 내용이 매우 클 경우 발생할 수 있는 환경 변수 크기 제한 문제를 회피하는 핵심적인 기법이다.
의미 있는 diff를 얻는 과정은 단순한 git diff 명령어 실행보다 복잡하다. GitHub PR 인터페이스에서 개발자가 보는 diff는 '3-dot diff' (base...head)로, 피처 브랜치가 베이스 브랜치에서 분기된 이후의 누적된 변경사항만을 보여준다. 이는 코드 리뷰에 가장 적합한 컨텍스트이다. 반면, 워크플로우에서 단순히 git diff <base> <head>를 실행하면 '2-dot diff'가 생성될 수 있으며, 이는 베이스 브랜치에 발생한 관련 없는 변경사항까지 포함하여 AI를 혼란스럽게 할 수 있다. GrantBirki/git-diff-action과 같은 전문 액션은 PR 컨텍스트를 정확히 이해하고 3-dot diff를 시뮬레이션하도록 설계되었다. 따라서 '컨텍스트 제공자'는 CI 환경의 복잡한 Git 연산으로부터 시스템의 나머지 부분을 보호하고, 의미론적으로 정확하고 정제된 코드 변경사항을 제공하는 중요한 추상화 계층 역할을 한다.
3.2. 프롬프트 조립
추출된 diff, PR 메타데이터, 페르소나별 지침을 하나의 일관된 프롬프트로 결합한다.
 * 구현:
   * 이 단계는 actions/setup-node를 통해 설정된 환경에서 실행되는 TypeScript 스크립트로 구현한다.
   * 스크립트의 역할은 다음과 같다:
     * 이전 단계에서 생성된 diff.json 파일을 읽는다.
     * JSON을 파싱하여 추가/수정된 파일의 최종 내용만을 추출한다. 원시 diff 형식(--- a/..., +++ b/...)은 LLM에게 불필요한 노이즈이므로, 변경된 코드의 최종 상태를 제공하는 것이 더 효과적이다.
     * GitHub 컨텍스트 객체를 통해 PR 제목(${{ github.event.pull_request.title }}) 및 본문(${{ github.event.pull_request.body }})과 같은 메타데이터에 접근한다.
     * 템플릿 리터럴을 사용하여 최종 프롬프트 문자열을 구성하고, 이를 파일(prompt.txt)로 저장하거나 다음 스텝에서 사용할 수 있도록 출력 변수로 설정한다.
IV. 패키지: AI 페르소나
개별 AI 에이전트의 구현을 정의한다. 각 페르소나는 특정 목표를 가진 별개의 기능 단위이며, 서로 다른 이벤트에 의해 트리거되고, 정교하게 설계된 프롬프트에 의해 유도된다.
아래 표는 시스템에 구현될 AI 페르소나들의 개요를 보여준다.
| 페르소나 이름 | 워크플로우 파일 | 트리거 이벤트 | 핵심 프롬프트 목표 | 출력 메커니즘 |
|---|---|---|---|---|
| PR 요약 | pull-request.yml | pull_request.opened | 변경사항에 대한 고수준 요약 생성 | 신규 PR 코멘트 생성 |
| 코드 리뷰어 | pull-request.yml, review.yml | pull_request.synchronize, issue_comment.created (/review 포함) | 코드 품질 및 정확성에 대한 심층 분석 수행 | 고정(sticky) 리뷰 코멘트 생성 또는 업데이트 |
| 테스트 생성기 | generate-tests.yml | issue_comment.created (/generate-tests 포함) | 제공된 코드 변경사항에 대한 단위 테스트 작성 | 코드 블록을 포함한 신규 PR 코멘트 생성 |
4.1. 페르소나: PR 요약 (PR Summarizer)
 * 트리거: pull_request.opened
 * 프롬프트 설계: run-gemini-cli에 전달될 프롬프트는 다음과 같이 구조화한다.
   당신은 "PR 요약" 역할을 수행하는 전문 소프트웨어 엔지니어입니다. 당신의 임무는 다른 개발자와 프로젝트 관리자를 위해 이 Pull Request의 변경사항에 대한 고수준 요약을 제공하는 것입니다.

**Pull Request 제목:** "${{ github.event.pull_request.title }}"
**Pull Request 설명:**
"""
${{ github.event.pull_request.body }}
"""

**코드 변경사항 (Diff):**
"""
// 처리된 diff.json 파일의 내용이 여기에 삽입됩니다.
"""

위 정보를 바탕으로 다음을 제공하십시오:
1.  **한 문장 요약:** 이 PR의 핵심 목표는 무엇입니까?
2.  **주요 변경사항 목록:** 가장 중요한 수정 사항을 글머리 기호 목록으로 나열하십시오 (예: "사용자 인증을 위한 신규 엔드포인트 추가", "성능 개선을 위한 데이터 처리 파이프라인 리팩토링").
3.  **잠재적 영향:** 잠재적 위험, 브레이킹 체인지, 또는 리뷰 시 특별한 주의가 필요한 영역을 간략하게 언급하십시오.

 * 호출: pull-request.yml 워크플로우의 summarize 작업에서 호출된다.
4.2. 페르소나: 코드 리뷰어 (Code Reviewer)
 * 트리거: pull_request.synchronize 또는 @gemini-cli /review 코멘트를 통한 온디맨드 요청.
 * 프롬프트 설계: 이 프롬프트는 더 상세하며, GEMINI.md의 컨텍스트를 암묵적으로 활용한다.
   당신은 꼼꼼한 "코드 리뷰어"이자 전문 시니어 소프트웨어 엔지니어입니다. 당신의 임무는 다음 코드 변경사항에 대한 철저한 리뷰를 수행하는 것입니다. 당신은 반드시 프로젝트의 표준과 모범 사례(당신에게 제공된 컨텍스트에 정의된)를 준수해야 합니다.

**Pull Request 제목:** "${{ github.event.pull_request.title }}"

**코드 변경사항 (Diff):**
"""
// 처리된 diff.json 파일의 내용이 여기에 삽입됩니다.
"""

다음을 중점적으로 코드를 분석하십시오:
1.  **버그 및 로직 오류:** 잠재적인 버그, 경쟁 조건(race condition), 또는 논리적 결함을 식별하십시오.
2.  **보안 취약점:** SQL 인젝션, 부적절한 오류 처리, 민감 데이터 노출과 같은 일반적인 취약점을 찾으십시오.
3.  **성능 문제:** 불필요한 루프나 비효율적인 데이터베이스 쿼리와 같이 비효율적인 코드에 대한 개선 사항을 제안하십시오.
4.  **모범 사례 및 스타일:** 코드가 확립된 디자인 패턴과 스타일 가이드라인을 따르는지 확인하십시오.
5.  **가독성 및 유지보수성:** 이해하기 어려운 코드에 대해 지적하고, 변수명, 주석, 구조에 대한 개선을 제안하십시오.

피드백은 구조화된 마크다운 형식으로 제공하십시오. 각 항목에 대해 파일명과 라인 번호, 문제 설명, 그리고 가능하다면 구체적인 코드 제안을 포함하십시오.

 * 호출: pull-request.yml의 review 작업 또는 review.yml 디스패치 워크플로우에서 호출된다.
4.3. 페르소나: 테스트 생성기 (Test Generator)
 * 트리거: @gemini-cli /generate-tests 코멘트를 통한 온디맨드 요청.
 * 프롬프트 설계:
   당신은 "테스트 생성기" AI입니다. 당신의 전문 분야는 고품질 단위 테스트를 작성하는 것입니다. 제공된 코드를 기반으로, Jest와 React Testing Library를 사용하여 포괄적인 단위 테스트 스위트를 작성하십시오.

**테스트 대상 코드:**
"""
// 사용자가 코드 스니펫을 붙여넣거나, 워크플로우가 diff에서 추출한 코드가 여기에 삽입됩니다.
"""

테스트는 다음을 포함해야 합니다:
1.  정상적인 시나리오 (Happy path).
2.  엣지 케이스 및 유효하지 않은 입력값.
3.  비동기 작업 및 상태 변화.

완성된 테스트 파일 전체 내용을 단일 TypeScript 마크다운 코드 블록 안에 제공하십시오.

 * 호출: 전용 generate-tests.yml 디스패치 워크플로우에서 호출된다.
V. 패키지: 피드백 통합자
이 마지막 모듈은 Gemini API로부터 받은 원시 출력(raw output)을 가공하여 GitHub PR 인터페이스 내에서 사용자에게 깔끔하고 유용하며 방해되지 않는 방식으로 제공하는 책임을 진다.
5.1. 코멘트 관리 전략
매 커밋마다 새로운 코멘트를 생성하여 PR을 어지럽히고 개발자에게 알림 피로를 유발하는 문제를 방지한다.
 * 구현:
   * PR이 여러 번의 synchronize 이벤트를 거치면서 개발자가 피드백에 따라 새 커밋을 푸시하는 것은 일반적인 상황이다. 이때마다 "코드 리뷰어"가 전체 리뷰 코멘트를 새로 게시한다면, PR 대화는 금세 관리하기 어려울 정도로 복잡해진다.
   * 이러한 부정적인 개발자 경험을 방지하기 위해, '고정 코멘트(sticky comment)' 전략을 채택한다. 이는 페르소나별로 단 하나의 영구적인 코멘트를 생성하고, 후속 실행에서는 이 코멘트의 내용을 업데이트하는 방식이다. 이를 통해 AI의 피드백은 항상 예측 가능하고 정돈된 단일 위치에 최신 상태로 유지된다.
   * 이 전략은 peter-evans/find-comment@v3와 peter-evans/create-or-update-comment@v4 액션의 조합으로 구현한다.
     * 코멘트 찾기: find-comment 액션을 사용하여 코멘트 본문에 포함된 고유 식별자(예: ``)를 기준으로 기존 리뷰 코멘트의 comment-id를 찾는다.
     * 생성 또는 업데이트: create-or-update-comment 액션을 호출한다. 이전 단계에서 comment-id가 발견되었다면 해당 코멘트의 내용을 교체(edit-mode: replace)하고, 발견되지 않았다면 새로운 코멘트를 생성한다.
5.2. 출력 포맷팅
Gemini의 원시 텍스트 출력을 구조가 잘 잡힌 가독성 높은 마크다운으로 변환한다.
 * 구현:
   * "컨텍스트 제공자" 패키지에서 사용된 TypeScript 스크립트를 확장하여 이 기능을 구현한다.
   * AI의 응답을 받은 후, 스크립트는 다음 작업을 수행한다:
     * 렌더링 문제를 방지하기 위해 출력을 정제(sanitize)한다.
     * 모든 코멘트에 표준 헤더(예: "### 🤖 Gemini 코드 리뷰")와 푸터(예: 자동 생성 및 업데이트 예정 안내 문구)를 추가한다.
     * 코드 제안이 마크다운 코드 블록 안에 언어 식별자(예: ```typescript)와 함께 올바르게 포맷팅되도록 보장한다.
     * 최종적으로 포맷팅된 문자열을 create-or-update-comment 액션의 body 입력값으로 전달한다.
VI. 결론
본 계획서는 Gemini AI와 GitHub Actions를 통합하여 지능형 코드 리뷰 및 작업 자동화 시스템을 구축하기 위한 체계적인 청사진을 제공한다. 이 시스템의 핵심적인 아키텍처 원칙은 다음과 같다.
 * 확장성 (Scalability): 중앙 디스패처 패턴을 채택하여 이벤트 라우팅과 실제 작업 실행을 분리함으로써, 새로운 AI 기능을 기존 시스템에 미치는 영향 없이 모듈식으로 추가할 수 있다.
 * 유지보수성 (Maintainability): GEMINI.md 파일을 통해 AI의 핵심 컨텍스트와 행동 지침을 코드로 관리("Prompt Engineering as Code")함으로써, 프로젝트 표준 변경 시 단일 파일을 수정하여 시스템 전체에 일관되게 적용할 수 있다.
 * 신뢰성 (Reliability): 복잡한 Git 연산을 추상화한 '컨텍스트 제공자'를 통해 AI에 항상 의미론적으로 정확하고 정제된 정보를 제공하여, 고품질의 결과를 일관되게 도출한다.
 * 사용자 경험 (User Experience): '고정 코멘트' 전략을 통해 PR 인터페이스를 깔끔하게 유지하고 알림 피로를 방지함으로써, 개발자가 AI의 피드백을 효과적으로 활용할 수 있는 환경을 조성한다.
이러한 원칙에 따라 구현된 시스템은 단순한 자동화 도구를 넘어, 개발팀의 생산성을 향상시키고 코드 품질을 높이며, 보다 효율적이고 협력적인 개발 문화를 조성하는 핵심적인 역할을 수행할 것이다.
